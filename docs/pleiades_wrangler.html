<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>classical_atlas.pleiades_wrangler API documentation</title>
<meta name="description" content="Classical Atlas : A Python Package for Open-Access Geospatial Datasets about the Ancient World
Developed by Annie K. Lamar (Stanford University | â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>classical_atlas.pleiades_wrangler</code></h1>
</header>
<section id="section-intro">
<p>Classical Atlas : A Python Package for Open-Access Geospatial Datasets about the Ancient World
Developed by Annie K. Lamar (Stanford University | kalamar@stanford.edu)</p>
<p>This module contains the methods you will use most often. With these methods, you can parse all Pleiades data,
create Pleiad objects representing Pleiades Places, add Places to a networkX graph, add edges representing
connections between places, and even add node attributes from other datasets (e.g. ToposText) to the graph.</p>
<p>To quickly obtain a graph all Pleiades places and connections, use the method <strong>get_pleiades_network_shortcut.</strong> You
can also use the methods individually if you want to change the default settings. To add data from ToposText,
create a graph of Pleiad objects and use <strong>add_topos_text_data_to_network()</strong>, passing the graph as a parameter.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Classical Atlas : A Python Package for Open-Access Geospatial Datasets about the Ancient World
Developed by Annie K. Lamar (Stanford University | kalamar@stanford.edu)

This module contains the methods you will use most often. With these methods, you can parse all Pleiades data,
create Pleiad objects representing Pleiades Places, add Places to a networkX graph, add edges representing
connections between places, and even add node attributes from other datasets (e.g. ToposText) to the graph.

To quickly obtain a graph all Pleiades places and connections, use the method **get_pleiades_network_shortcut.** You
can also use the methods individually if you want to change the default settings. To add data from ToposText,
create a graph of Pleiad objects and use **add_topos_text_data_to_network()**, passing the graph as a parameter.
&#34;&#34;&#34;
from collections import defaultdict
import networkx as nx
import downloaders
from pleiad import Pleiad
import topos_wrangler


def make_pleiades_objects(download_latest_data=False):
    &#34;&#34;&#34;
    Parses Pleiades data and returns a list of Pleiad objects. Each Pleiad object represents a single Pleiades place.
    With default settings, this method will use the JSON file included in the release of this Python package. If you
    want to make sure you are using the most recent Pleiades JSON file, set the parameter **download_latest_data=True**.
    Note that downloading recent data will take quite a while.
    &#34;&#34;&#34;
    if download_latest_data:
        print(&#34;Warning: Pleiades data files are large and may require considerable time to download.&#34;)
        input(&#34;Press Enter to continue...&#34;)
        data = downloaders.get_pleiades_data(
            &#34;http://atlantides.org/downloads/pleiades/json/pleiades-places-latest.json.gz&#34;)
    else:
        raw_data_file = downloaders.unzip_gz(&#34;data/pleiades-places-latest.json.gz&#34;)
        data = downloaders.get_df(raw_data_file)
    data = data[&#39;@graph&#39;]
    pleiades = []
    for row in range(len(data)):
        pleiades.append(Pleiad(data[row]))
    return pleiades


def find_keyword(list_of_pleiads, keyword, print_results=False):
    &#34;&#34;&#34;Search through text fields of Pleiad objects, locations, and names for a specified keyword.

    Parameters
    ----------
    list_of_pleiads : list
        list of pleiad objects to search through
    keyword : string
        keyword to search for
    print_results : boolean, default=False
        if True, print results before returning

    Returns
    -------
    dictionary
        dictionary of lists; contains pleiad objects, locations, and names relavant to keyword
    &#34;&#34;&#34;
    found_list = defaultdict(list)
    for pleiad in list_of_pleiads:
        if (pleiad.description and keyword in pleiad.description) \
                or (pleiad.details and keyword in pleiad.details) \
                or (pleiad.title and keyword in pleiad.title):
            found_list[&#39;pleiad&#39;].append(pleiad)
        for location in pleiad.locations.keys():
            if (location.title and keyword in location.title) \
                    or (location.location_description and keyword in location.location_description) \
                    or (location.location_details and keyword in location.location_details):
                found_list[&#39;location&#39;].append(location)
        for name in pleiad.names.keys():
            if keyword in name.romanized_name \
                    or (name.description and keyword in name.description) \
                    or (name.language and keyword in name.language):
                found_list[&#39;name&#39;].append(name)
    if print_results:
        print(&#34;Pleiades relevant to keyword &#34; + keyword + &#34;: &#34;)
        for pl in found_list[&#39;pleiad&#39;]:
            print(&#34;     &#34; + pl.title)
        print(&#34;Locations relevant to keyword &#34; + keyword + &#34;: &#34;)
        for loc in found_list[&#39;location&#39;]:
            print(&#34;     &#34; + loc.title)
        print(&#34;Names relevant to keyword &#34; + keyword + &#34;: &#34;)
        for name in found_list[&#39;name&#39;]:
            print(&#34;     &#34; + name.romanized_name)
    return found_list


def get_pleiades_as_nodes(list_of_pleiades):
    &#34;&#34;&#34;
    Add nodes representing places to a graph. Each node is a Pleiades &#34;Place&#34; and has linked Locations and Names.

    Parameters
    ----------
    list_of_pleiades : list
        a list of Pleiades objects

    Returns
    -------
    Graph
        a NetworkX Graph with nodes representing places
    &#34;&#34;&#34;
    G = nx.Graph()
    for pl in list_of_pleiades:
        G.add_node(pl)
    return G


def add_connections_as_edges(graph):
    &#34;&#34;&#34;
    Adds edges between places with connections. These connections are taken from the Pleiades metadata. Connection
    type is also included as an edge attribute. More information about connections is available here:
    https://pleiades.stoa.org/help/what-are-connections.

    Parameters
    ----------
    graph : Graph
        a networkX Graph with defined nodes

    Returns
    -------
    Graph
        a networkX Graph with added edges
    &#34;&#34;&#34;
    temp = []
    for node in graph.nodes:
        temp.append(node)
    for pl in temp:
        for connection in pl.connections.keys():
            match = None
            for node in temp:
                if connection == node.id:
                    match = node
                    break
            graph.add_edge(pl, match, connection_type=pl.connections[connection][0])
    return graph


def get_pleiades_network_shortcut():
    &#34;&#34;&#34;
    Get a networkX Graph representing the entire Pleiades dataset. This method is a shortcut to parse all Pleiades
    data, create Pleiad objects representing every Pleiades place with linked Locations and Names, add those objects
    to a Graph as nodes, and add edges that represent connections (and their attributes) between Places. This method
    takes no arguments and returns a networkX Graph object.

    Returns
    -------
    graph
        a NetworkX graph with nodes representing Pleiades places and edges representing connections between places
    &#34;&#34;&#34;
    pleiades = make_pleiades_objects()
    gr = get_pleiades_as_nodes(pleiades)
    gr = add_connections_as_edges(gr)
    return gr


def add_topos_text_data_to_network(graph):
    &#34;&#34;&#34;
    Add topos text data to the network. This method parses through all Topos Text data, matches the Topos Text data
    to Pleiades IDs when possible, and adds a list of textual references as a node attribute. The graph that you pass
    to this method should be a networkX Graph object created with the methods found in the pleiades_wrangler module.
    Edges are not required, but do not impact the functionality if present. The returned Graph is the same except
    nodes have one added attribute: a list of texts that reference that particular place.

    Parameters
    ----------
    graph : Graph
        a graph with nodes representing Pleiades objects

    Returns
    -------
    Graph
        a Graph with added node attributes of list of textual references
    &#34;&#34;&#34;
    df = topos_wrangler.get_topos_data()
    topos_refs = topos_wrangler.switch_to_pleiades_ids(df, topos_wrangler.parse_topos_place_refs())
    topos_refs = topos_wrangler.swap_key_value_pairs(topos_refs)
    G = nx.Graph()
    for topos_id in topos_refs.keys():
        for node in graph.nodes:
            if node.id == topos_id:
                G.add_node(node, textual_refs=topos_refs[topos_id])
    return G</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="classical_atlas.pleiades_wrangler.add_connections_as_edges"><code class="name flex">
<span>def <span class="ident">add_connections_as_edges</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds edges between places with connections. These connections are taken from the Pleiades metadata. Connection
type is also included as an edge attribute. More information about connections is available here:
<a href="https://pleiades.stoa.org/help/what-are-connections.">https://pleiades.stoa.org/help/what-are-connections.</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>Graph</code></dt>
<dd>a networkX Graph with defined nodes</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Graph</code></dt>
<dd>a networkX Graph with added edges</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_connections_as_edges(graph):
    &#34;&#34;&#34;
    Adds edges between places with connections. These connections are taken from the Pleiades metadata. Connection
    type is also included as an edge attribute. More information about connections is available here:
    https://pleiades.stoa.org/help/what-are-connections.

    Parameters
    ----------
    graph : Graph
        a networkX Graph with defined nodes

    Returns
    -------
    Graph
        a networkX Graph with added edges
    &#34;&#34;&#34;
    temp = []
    for node in graph.nodes:
        temp.append(node)
    for pl in temp:
        for connection in pl.connections.keys():
            match = None
            for node in temp:
                if connection == node.id:
                    match = node
                    break
            graph.add_edge(pl, match, connection_type=pl.connections[connection][0])
    return graph</code></pre>
</details>
</dd>
<dt id="classical_atlas.pleiades_wrangler.add_topos_text_data_to_network"><code class="name flex">
<span>def <span class="ident">add_topos_text_data_to_network</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Add topos text data to the network. This method parses through all Topos Text data, matches the Topos Text data
to Pleiades IDs when possible, and adds a list of textual references as a node attribute. The graph that you pass
to this method should be a networkX Graph object created with the methods found in the pleiades_wrangler module.
Edges are not required, but do not impact the functionality if present. The returned Graph is the same except
nodes have one added attribute: a list of texts that reference that particular place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>Graph</code></dt>
<dd>a graph with nodes representing Pleiades objects</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Graph</code></dt>
<dd>a Graph with added node attributes of list of textual references</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_topos_text_data_to_network(graph):
    &#34;&#34;&#34;
    Add topos text data to the network. This method parses through all Topos Text data, matches the Topos Text data
    to Pleiades IDs when possible, and adds a list of textual references as a node attribute. The graph that you pass
    to this method should be a networkX Graph object created with the methods found in the pleiades_wrangler module.
    Edges are not required, but do not impact the functionality if present. The returned Graph is the same except
    nodes have one added attribute: a list of texts that reference that particular place.

    Parameters
    ----------
    graph : Graph
        a graph with nodes representing Pleiades objects

    Returns
    -------
    Graph
        a Graph with added node attributes of list of textual references
    &#34;&#34;&#34;
    df = topos_wrangler.get_topos_data()
    topos_refs = topos_wrangler.switch_to_pleiades_ids(df, topos_wrangler.parse_topos_place_refs())
    topos_refs = topos_wrangler.swap_key_value_pairs(topos_refs)
    G = nx.Graph()
    for topos_id in topos_refs.keys():
        for node in graph.nodes:
            if node.id == topos_id:
                G.add_node(node, textual_refs=topos_refs[topos_id])
    return G</code></pre>
</details>
</dd>
<dt id="classical_atlas.pleiades_wrangler.find_keyword"><code class="name flex">
<span>def <span class="ident">find_keyword</span></span>(<span>list_of_pleiads, keyword, print_results=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Search through text fields of Pleiad objects, locations, and names for a specified keyword.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>list_of_pleiads</code></strong> :&ensp;<code>list</code></dt>
<dd>list of pleiad objects to search through</dd>
<dt><strong><code>keyword</code></strong> :&ensp;<code>string</code></dt>
<dd>keyword to search for</dd>
<dt><strong><code>print_results</code></strong> :&ensp;<code>boolean</code>, default=<code>False</code></dt>
<dd>if True, print results before returning</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dictionary</code></dt>
<dd>dictionary of lists; contains pleiad objects, locations, and names relavant to keyword</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_keyword(list_of_pleiads, keyword, print_results=False):
    &#34;&#34;&#34;Search through text fields of Pleiad objects, locations, and names for a specified keyword.

    Parameters
    ----------
    list_of_pleiads : list
        list of pleiad objects to search through
    keyword : string
        keyword to search for
    print_results : boolean, default=False
        if True, print results before returning

    Returns
    -------
    dictionary
        dictionary of lists; contains pleiad objects, locations, and names relavant to keyword
    &#34;&#34;&#34;
    found_list = defaultdict(list)
    for pleiad in list_of_pleiads:
        if (pleiad.description and keyword in pleiad.description) \
                or (pleiad.details and keyword in pleiad.details) \
                or (pleiad.title and keyword in pleiad.title):
            found_list[&#39;pleiad&#39;].append(pleiad)
        for location in pleiad.locations.keys():
            if (location.title and keyword in location.title) \
                    or (location.location_description and keyword in location.location_description) \
                    or (location.location_details and keyword in location.location_details):
                found_list[&#39;location&#39;].append(location)
        for name in pleiad.names.keys():
            if keyword in name.romanized_name \
                    or (name.description and keyword in name.description) \
                    or (name.language and keyword in name.language):
                found_list[&#39;name&#39;].append(name)
    if print_results:
        print(&#34;Pleiades relevant to keyword &#34; + keyword + &#34;: &#34;)
        for pl in found_list[&#39;pleiad&#39;]:
            print(&#34;     &#34; + pl.title)
        print(&#34;Locations relevant to keyword &#34; + keyword + &#34;: &#34;)
        for loc in found_list[&#39;location&#39;]:
            print(&#34;     &#34; + loc.title)
        print(&#34;Names relevant to keyword &#34; + keyword + &#34;: &#34;)
        for name in found_list[&#39;name&#39;]:
            print(&#34;     &#34; + name.romanized_name)
    return found_list</code></pre>
</details>
</dd>
<dt id="classical_atlas.pleiades_wrangler.get_pleiades_as_nodes"><code class="name flex">
<span>def <span class="ident">get_pleiades_as_nodes</span></span>(<span>list_of_pleiades)</span>
</code></dt>
<dd>
<div class="desc"><p>Add nodes representing places to a graph. Each node is a Pleiades "Place" and has linked Locations and Names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>list_of_pleiades</code></strong> :&ensp;<code>list</code></dt>
<dd>a list of Pleiades objects</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Graph</code></dt>
<dd>a NetworkX Graph with nodes representing places</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pleiades_as_nodes(list_of_pleiades):
    &#34;&#34;&#34;
    Add nodes representing places to a graph. Each node is a Pleiades &#34;Place&#34; and has linked Locations and Names.

    Parameters
    ----------
    list_of_pleiades : list
        a list of Pleiades objects

    Returns
    -------
    Graph
        a NetworkX Graph with nodes representing places
    &#34;&#34;&#34;
    G = nx.Graph()
    for pl in list_of_pleiades:
        G.add_node(pl)
    return G</code></pre>
</details>
</dd>
<dt id="classical_atlas.pleiades_wrangler.get_pleiades_network_shortcut"><code class="name flex">
<span>def <span class="ident">get_pleiades_network_shortcut</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a networkX Graph representing the entire Pleiades dataset. This method is a shortcut to parse all Pleiades
data, create Pleiad objects representing every Pleiades place with linked Locations and Names, add those objects
to a Graph as nodes, and add edges that represent connections (and their attributes) between Places. This method
takes no arguments and returns a networkX Graph object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>graph</code></dt>
<dd>a NetworkX graph with nodes representing Pleiades places and edges representing connections between places</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pleiades_network_shortcut():
    &#34;&#34;&#34;
    Get a networkX Graph representing the entire Pleiades dataset. This method is a shortcut to parse all Pleiades
    data, create Pleiad objects representing every Pleiades place with linked Locations and Names, add those objects
    to a Graph as nodes, and add edges that represent connections (and their attributes) between Places. This method
    takes no arguments and returns a networkX Graph object.

    Returns
    -------
    graph
        a NetworkX graph with nodes representing Pleiades places and edges representing connections between places
    &#34;&#34;&#34;
    pleiades = make_pleiades_objects()
    gr = get_pleiades_as_nodes(pleiades)
    gr = add_connections_as_edges(gr)
    return gr</code></pre>
</details>
</dd>
<dt id="classical_atlas.pleiades_wrangler.make_pleiades_objects"><code class="name flex">
<span>def <span class="ident">make_pleiades_objects</span></span>(<span>download_latest_data=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parses Pleiades data and returns a list of Pleiad objects. Each Pleiad object represents a single Pleiades place.
With default settings, this method will use the JSON file included in the release of this Python package. If you
want to make sure you are using the most recent Pleiades JSON file, set the parameter <strong>download_latest_data=True</strong>.
Note that downloading recent data will take quite a while.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_pleiades_objects(download_latest_data=False):
    &#34;&#34;&#34;
    Parses Pleiades data and returns a list of Pleiad objects. Each Pleiad object represents a single Pleiades place.
    With default settings, this method will use the JSON file included in the release of this Python package. If you
    want to make sure you are using the most recent Pleiades JSON file, set the parameter **download_latest_data=True**.
    Note that downloading recent data will take quite a while.
    &#34;&#34;&#34;
    if download_latest_data:
        print(&#34;Warning: Pleiades data files are large and may require considerable time to download.&#34;)
        input(&#34;Press Enter to continue...&#34;)
        data = downloaders.get_pleiades_data(
            &#34;http://atlantides.org/downloads/pleiades/json/pleiades-places-latest.json.gz&#34;)
    else:
        raw_data_file = downloaders.unzip_gz(&#34;data/pleiades-places-latest.json.gz&#34;)
        data = downloaders.get_df(raw_data_file)
    data = data[&#39;@graph&#39;]
    pleiades = []
    for row in range(len(data)):
        pleiades.append(Pleiad(data[row]))
    return pleiades</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="classical_atlas" href="index.html">classical_atlas</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="classical_atlas.pleiades_wrangler.add_connections_as_edges" href="#classical_atlas.pleiades_wrangler.add_connections_as_edges">add_connections_as_edges</a></code></li>
<li><code><a title="classical_atlas.pleiades_wrangler.add_topos_text_data_to_network" href="#classical_atlas.pleiades_wrangler.add_topos_text_data_to_network">add_topos_text_data_to_network</a></code></li>
<li><code><a title="classical_atlas.pleiades_wrangler.find_keyword" href="#classical_atlas.pleiades_wrangler.find_keyword">find_keyword</a></code></li>
<li><code><a title="classical_atlas.pleiades_wrangler.get_pleiades_as_nodes" href="#classical_atlas.pleiades_wrangler.get_pleiades_as_nodes">get_pleiades_as_nodes</a></code></li>
<li><code><a title="classical_atlas.pleiades_wrangler.get_pleiades_network_shortcut" href="#classical_atlas.pleiades_wrangler.get_pleiades_network_shortcut">get_pleiades_network_shortcut</a></code></li>
<li><code><a title="classical_atlas.pleiades_wrangler.make_pleiades_objects" href="#classical_atlas.pleiades_wrangler.make_pleiades_objects">make_pleiades_objects</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>